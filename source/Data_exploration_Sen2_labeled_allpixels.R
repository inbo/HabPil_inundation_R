# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#       Analysis and Modeling of Processed Pixel Data
#
# This script loads a pre-processed CSV file containing pixel attributes
# (coordinates, fractions, S2 bands, indices, and derived labels).
# It performs data summary, visualization (boxplots), and applies a
# pre-trained decision tree model to generate new predictions.
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


## Part 1: Setup & Configuration
# ==============================================================================
message("Part 1: Initializing Setup and Configuration...")

# --- 1.1: Load Required Packages ---
message("--> Loading required R packages: dplyr, ggplot2, tidyr")
# 'terra' is not strictly needed if only working with the data frame, but good practice.
# 'rpart' or other model packages may be needed for the predict() function to work.
if (!requireNamespace("dplyr", quietly = TRUE)) stop("Package 'dplyr' is required.")
if (!requireNamespace("ggplot2", quietly = TRUE)) stop("Package 'ggplot2' is required.")
if (!requireNamespace("tidyr", quietly = TRUE)) stop("Package 'tidyr' is required.")
if (!requireNamespace("sf", quietly = TRUE)) message("[INFO] 'sf' package not found, will not be used.")
library(dplyr)
library(ggplot2)
library(tidyr)
# library(rpart) # Example: You may need to load the package for your specific model

# --- 1.2: Source Utility and Configuration Files ---
message("--> Sourcing utility and configuration files...")
# Define paths to helper scripts.
gdrive_utils_path <- "source/gdrive_utils.R"
spatial_utils_path <- "source/spatial_processing_utils.R"
config_path <- "source/config.R"

# Helper function to source files safely.
source_if_exists <- function(file_path, file_description) {
  if (!file.exists(file_path)) {
    stop(paste(file_description, "not found at:", normalizePath(file_path, mustWork = FALSE)))
  }
  message("    Sourcing ", file_description, " from: ", normalizePath(file_path))
  source(file_path, local = FALSE, chdir = TRUE)
}

# Source the files. This loads project-specific variables from config.R.
source_if_exists(gdrive_utils_path, "Google Drive utilities (gdrive_utils.R)")
source_if_exists(config_path, "Configuration settings (config.R)")
source_if_exists(spatial_utils_path, "Spatial processing utilities (spatial_processing_utils.R)")

# --- 1.3: Define Input File Path from Configuration ---
message("--> Defining input CSV file path...")
# This path should point to the CSV file generated by the previous script.
# The user specified this exact filename.
input_csv_filename <- paste0(study_site_name, "_", study_year, "_pixel_data_S2_and_fractions.csv")
# This assumes the CSV is in a 'pixel_data_tables' subdirectory. Adjust if needed.
input_csv_directory <- file.path(output_root_dir, "fraction rasters", study_site_name, study_year)
input_csv_path <- file.path(input_csv_directory, input_csv_filename)
message("    Expected path for input CSV: ", input_csv_path)

message("--> Setup and configuration complete. ✅")
# --- End of Part 1 ---


## Part 2: Load and Prepare Data
# ==============================================================================
message("\nPart 2: Loading and Preparing Pixel Data from CSV...")

# --- 2.1: Load the CSV File ---
if (!file.exists(input_csv_path)) {
  stop(paste("Input CSV file not found:", input_csv_path,
             "\nPlease ensure the path and filename are correct and the previous script has been run successfully."))
}
message("--> Loading data from: ", input_csv_path)
tryCatch({
  # Using read.csv from base R. For very large files, consider data.table::fread()
  pixel_data_df <- read.csv(input_csv_path, stringsAsFactors = TRUE) # stringsAsFactors=TRUE helps with label columns
  message("    Successfully loaded ", format(nrow(pixel_data_df), big.mark=","), " pixels with ", ncol(pixel_data_df), " attributes.")
  message("    Initial columns in loaded data frame:")
  print(names(pixel_data_df))
}, error = function(e) {
  stop(paste("Error loading CSV file:", e$message))
})

 # --- 2.2: Standardize Column Names to Lowercase ---
# Your original script standardized names to lowercase, which is important for
# consistency, especially when the model expects specific (e.g., lowercase) predictor names.
message("--> Converting all column names to lowercase for consistency...")
names(pixel_data_df) <- tolower(names(pixel_data_df))
message("    Column names after lowercasing:")
print(names(pixel_data_df))
message("--> Data loaded and prepared successfully. ✅")
# --- End of Part 2 ---


## Part 3: Data Summary & Visualization
# ==============================================================================
message("\nPart 3: Data Summary and Visualization...")

# --- 3.1: Summarize Pixel Counts by Category ---
message("--> Summarizing pixel counts by category...")
# Note: The 'dominant_label' and 'mixture_category' columns are now lowercase.
if ("mixture_category" %in% names(pixel_data_df)) {
  message("    Counts per 'mixture_category':")
  print(table(pixel_data_df$mixture_category, dnn = "Mixture Category"))
}
if ("dominant_label" %in% names(pixel_data_df)) {
  message("\n    Counts per 'dominant_label':")
  print(table(pixel_data_df$dominant_label, dnn = "Dominant Label"))
}

# --- 3.2: Summarize Pixel Counts as a Pivot Table ---
message("--> Summarizing pixel counts in a pivot table...")

# Note: The 'dominant_label' and 'mixture_category' columns were converted to lowercase in Part 2.
if (!all(c("dominant_label", "mixture_category") %in% names(pixel_data_df))) {
  message("[WARN] 'dominant_label' and/or 'mixture_category' columns not found. Skipping pivot table summary.")
} else {
  
  message("    Generating pivot table: 'dominant_label' (rows) vs. 'mixture_category' (columns)...")
  
  # To ensure a logical column order (pure, mixed, very_mixed), we can convert
  # the 'mixture_category' column to a factor with a specified level order.
  mixture_levels_order <- c("pure", "mixed", "very_mixed")
  # We only use levels that are actually present in the data to avoid empty columns.
  actual_levels_in_data <- intersect(mixture_levels_order, unique(pixel_data_df$mixture_category))
  
  if (length(actual_levels_in_data) > 0) {
    # Temporarily create an ordered factor for tabulation
    mixture_category_ordered <- factor(pixel_data_df$mixture_category, levels = actual_levels_in_data)
    
    # Create the two-way contingency table (the pivot table)
    pivot_table_counts <- table(
      `Dominant Label` = pixel_data_df$dominant_label, 
      `Mixture Category` = mixture_category_ordered
    )
    
    # Use addmargins() to add row and column totals, which are labeled "Sum"
    pivot_table_with_totals <- addmargins(pivot_table_counts)
    
    message("\n    --- Pixel Count Summary: Dominant Label vs. Mixture Category ---")
    print(pivot_table_with_totals)
    message("    ------------------------------------------------------------------\n")
    
  } else {
    # Fallback in case the standard category names aren't found
    message("[WARN] No standard mixture categories ('pure', 'mixed', 'very_mixed') found. Printing a simple table without totals.")
    print(table(pixel_data_df$dominant_label, pixel_data_df$mixture_category))
  }
}

# --- 3.3: Create Stacked Bar Plot of Pixel Counts by Label and Mixture ---
message("\n--> Generating a stacked horizontal bar plot for pixel counts...")

# Check if the necessary columns exist
if (!all(c("dominant_label", "mixture_category") %in% names(pixel_data_df))) {
  message("[WARN] 'dominant_label' and/or 'mixture_category' columns not found. Skipping plot.")
} else {
  
  # 1. Prepare data for plotting by counting each combination
  plot_data <- pixel_data_df %>%
    filter(!is.na(dominant_label) & !is.na(mixture_category)) %>%
    count(dominant_label, mixture_category, name = "pixel_count")
  
  if (nrow(plot_data) == 0) {
    message("    [INFO] No data available to plot after filtering for non-NA labels.")
  } else {
    
    # 2. Define the color palette for the dominant labels
    main_label_colors <- c(
      "inundated" = "#4cd2de",
      "not inundated" = "#dc5199",
      "other" = "#86eb79",
      "uncertain" = "#ff7f00"
    )
    
    # 3. Prepare data for plotting: order factors
    # Order mixture_category to stack pure -> mixed -> very_mixed from left to right.
    # To do this, the factor levels must be in the REVERSE order.
    plot_data$mixture_category <- factor(
      plot_data$mixture_category, 
      levels = c("very_mixed", "mixed", "pure") 
    )
    
    # Order dominant_label bars from longest to shortest
    label_totals <- plot_data %>%
      group_by(dominant_label) %>%
      summarize(total_count = sum(pixel_count)) %>%
      arrange(total_count)
    
    plot_data$dominant_label <- factor(
      plot_data$dominant_label, 
      levels = label_totals$dominant_label
    )
    
    # Calculate text label positions to match the stacking order
    plot_data <- plot_data %>%
      arrange(dominant_label, desc(mixture_category)) %>%
      group_by(dominant_label) %>%
      mutate(
        label_position = cumsum(pixel_count) - 0.5 * pixel_count,
        total_pixels_in_bar = sum(pixel_count)
      )
    
    # 4. Create the stacked horizontal bar plot
    message("    Generating plot with reversed legend order...")
    stacked_bar_plot <- ggplot(plot_data,
                               aes(y = dominant_label, x = pixel_count, fill = dominant_label)) +
      # Use alpha aesthetic to create shades based on mixture_category
      geom_col(aes(alpha = mixture_category)) +
      
      # Apply the main colors for each dominant_label
      scale_fill_manual(
        name = "Dominant Label", # Set title for the color legend
        values = main_label_colors
      ) +
      
      # Manually define the transparency levels for each mixture category
      scale_alpha_manual(
        name = "Mixture Level", # Set title for the transparency legend
        values = c(
          "pure" = 1.0,         # Fully opaque
          "mixed" = 0.7,        # Partially transparent
          "very_mixed" = 0.4    # More transparent
        ),
        breaks = c("pure", "mixed", "very_mixed"),
        labels = c("Pure (>=90%)", "Mixed (60-90%)", "Very Mixed (<=60%)")
      ) +
      
      # Add text labels for the counts on the bars
      geom_text(
        aes(x = label_position, label = pixel_count),
        data = . %>% filter(pixel_count / total_pixels_in_bar > 0.05),
        size = 3.5, color = "white", fontface = "bold"
      ) +
      
      # Customize labels and theme
      labs(
        title = "Pixel Count by Dominant Label and Mixture Level",
        subtitle = if(exists("study_site_name")) paste("Site:", study_site_name, "| Year:", study_year) else "",
        x = "Number of Pixels",
        y = "Dominant Label"
      ) +
      theme_classic() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.line = element_line(colour = "black"),
        axis.ticks = element_line(colour = "black"),
        legend.position = "top",
        legend.box = "vertical"
      ) +
      
      # This 'guides' function tells ggplot how to draw the legends.
      guides(
        # Reverse the order of the fill legend to match the plot's top-to-bottom order.
        fill = guide_legend(reverse = TRUE),
        
        # Keep the customization for the alpha legend.
        alpha = guide_legend(
          override.aes = list(fill = "grey50") # This makes the alpha legend swatches shades of grey
        )
      )
    
    # Print the final plot
    print(stacked_bar_plot)
    message("--> Stacked horizontal bar plot with corrected legend order generated successfully. ✅")
    
    # Optional: Save the plot
    plot_output_dir <- file.path(output_root_dir, "plots", study_site_name, study_year)
    if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
    plot_filepath <- file.path(plot_output_dir, paste0(study_site_name, "_", study_year, "_stacked_bar_plot.png"))
    
    tryCatch({
      ggsave(plot_filepath, plot = stacked_bar_plot, width = 10, height = 8, dpi = 300)
      message("    Plot saved to: ", plot_filepath)
    }, error = function(e) { message("[WARN] Could not save plot: ", e$message) })
    
  } # End if(nrow(plot_data) > 0)
} # End if(all columns exist)
message("--> Data summary and visualization complete. ✅")


# --- 3.2: Generate Boxplots for "Pure" Pixels ---
message("\n--> Generating boxplots to visualize attribute distributions for 'pure' pixels...")

# Prerequisite: Check if the necessary data frame and columns are available.
if (!exists("pixel_data_df") || !all(c("mixture_category", "dominant_label") %in% names(pixel_data_df))) {
  message("    [INFO] 'pixel_data_df' with required label columns not found. Skipping plot.")
} else {
  
  # 1. Filter data to include only pixels classified as "pure"
  pure_labels_df <- pixel_data_df[which(pixel_data_df$mixture_category == "pure"), ]
  
  if (nrow(pure_labels_df) == 0) {
    message("    [INFO] No 'pure' pixels found in the data to plot.")
  } else {
    message("    Found ", format(nrow(pure_labels_df), big.mark=","), " 'pure' pixels for visualization.")
    
    # 2. Prepare data for plotting by setting a custom order for the x-axis
    message("    Setting custom order for plot axis...")
    
    # Define the desired order for the labels on the axis.
    manual_order <- c('inundated', 'not inundated', 'other', 'uncertain')
    
    # Identify which of these desired labels are actually present in the current data.
    levels_present_in_data <- intersect(manual_order, unique(pure_labels_df$dominant_label))
    
    # Re-level the dominant_label column. This ensures the plot axis follows your manual order.
    # Any labels in the data but not in 'manual_order' will appear at the end.
    if(length(levels_present_in_data) > 0) {
      unordered_labels <- setdiff(unique(pure_labels_df$dominant_label), levels_present_in_data)
      final_plot_order <- c(levels_present_in_data, unordered_labels)
      pure_labels_df$dominant_label <- factor(pure_labels_df$dominant_label, levels = final_plot_order)
    }
    
    # 3. Identify all numeric attributes to be plotted
    # a) Scaled Sentinel-2 bands (columns ending with '_scaled')
    scaled_s2_band_plot_cols <- names(pure_labels_df)[
      startsWith(names(pure_labels_df), "b") & endsWith(names(pure_labels_df), "_scaled")
    ]
    # b) Spectral Index columns
    index_plot_cols <- c("ndvi", "ndwi_mf", "mndwi11", "mndwi12", "ndmi_gao11", "str1", "str2")
    index_plot_cols_exist <- index_plot_cols[index_plot_cols %in% names(pure_labels_df)]
    
    cols_for_boxplotting <- c(scaled_s2_band_plot_cols, index_plot_cols_exist)
    
    if (length(cols_for_boxplotting) == 0) {
      message("    [WARN] No scaled S2 band or spectral index columns identified for plotting.")
    } else {
      message("    Variables selected for plotting: ", paste(cols_for_boxplotting, collapse=", "))
      
      # 4. Reshape data from a wide to a long format, which is required for faceting in ggplot
      pure_labels_long_df <- tidyr::pivot_longer(
        pure_labels_df,
        cols = all_of(cols_for_boxplotting),
        names_to = "variable_name",
        values_to = "value"
      )
      # Remove any non-finite values (NA, Inf) that would cause errors in plotting
      pure_labels_long_df <- pure_labels_long_df[is.finite(pure_labels_long_df$value), ]
      
      # 5. Check for the custom color definition
      if (!exists("main_label_colors")) {
        message("    [WARN] 'main_label_colors' vector not found. Using default ggplot2 colors.")
        main_label_colors <- NULL 
      } else {
        names(main_label_colors) <- tolower(names(main_label_colors))
      }
      
      # 6. Generate the final plot
      if(nrow(pure_labels_long_df) > 0) {
        message("    Generating faceted boxplots...")
        boxplot_collection <- ggplot(pure_labels_long_df, aes(x = dominant_label, y = value, fill = dominant_label)) +
          geom_boxplot() +
          facet_wrap(~ variable_name, scales = "free_y") +
          labs(
            title = "Distribution of S2 Bands & Indices for 'Pure' Dominant Labels",
            subtitle = paste("Site:", study_site_name, "| Year:", study_year),
            x = "Dominant Label (Mixture Category: Pure)",
            y = "Value (Scaled Reflectance or Index)"
          ) +
          theme_bw() +
          theme(
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
            plot.subtitle = element_text(hjust = 0.5),
            strip.text = element_text(face = "bold"),
            legend.position = "right" # Ensures the legend is visible
          )
        
        # Apply custom colors only if the color map was found and is valid
        if (!is.null(main_label_colors)) {
          boxplot_collection <- boxplot_collection + scale_fill_manual(
            name = "Dominant Label", # Sets the title for the legend
            values = main_label_colors
          )
        }
        
        print(boxplot_collection)
        message("--> Boxplots generated successfully. ✅")
        
        # 7. Save the plot to a file
        plot_output_dir <- file.path(output_root_dir, "boxplots", study_site_name, study_year)
        if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
        plot_filepath <- file.path(plot_output_dir, paste0(study_site_name, "_", study_year, "_boxplot_pure_labels.png"))
        
        tryCatch({
          ggsave(plot_filepath, plot = boxplot_collection, width = 14, height = 10, dpi = 300)
          message("    Boxplot saved to: ", plot_filepath)
        }, error = function(e) { message("[WARN] Could not save boxplot: ", e$message) })
      } else {
        message("    [INFO] No data available for plotting after filtering and reshaping.")
      }
    }
  }
}

# --- 3.3: Generate Boxplots for "Pure" AND "Mixed" Pixel Categories ---
message("\n--> Generating boxplots for combined 'pure' and 'mixed' pixel categories...")

# Prerequisite: Check if the necessary data frame and columns are available.
if (!exists("pixel_data_df") || !all(c("mixture_category", "dominant_label") %in% names(pixel_data_df))) {
  message("    [WARN] 'pixel_data_df' with required label columns not found. Skipping plot.")
} else {
  
  # 1. Filter data to select all pixels where mixture_category is either "pure" or "mixed".
  message("    Filtering data to select all 'pure' and 'mixed' pixels...")
  pure_and_mixed_df <- pixel_data_df[
    which(pixel_data_df$mixture_category %in% c("pure", "mixed")), 
  ]
  
  if (nrow(pure_and_mixed_df) == 0) {
    message("    [INFO] No 'pure' or 'mixed' pixels found in the data to plot.")
  } else {
    message("    Found ", format(nrow(pure_and_mixed_df), big.mark=","), " pixels for this combined visualization.")
    
    # 2. Prepare data for plotting by setting a custom order for the x-axis.
    message("    Setting custom order for plot axis...")
    
    # Define the desired order for the labels on the axis.
    manual_order <- c('inundated', 'not inundated', 'other', 'uncertain')
    
    # Use only the levels present in this specific filtered dataset.
    levels_present_in_data <- intersect(manual_order, unique(pure_and_mixed_df$dominant_label))
    
    # Append any other existing labels to the end of the order.
    unordered_labels <- setdiff(unique(pure_and_mixed_df$dominant_label), levels_present_in_data)
    final_plot_order <- c(levels_present_in_data, unordered_labels)
    pure_and_mixed_df$dominant_label <- factor(pure_and_mixed_df$dominant_label, levels = final_plot_order)
    
    # 3. Identify all numeric attributes to be plotted.
    scaled_s2_band_plot_cols <- names(pure_and_mixed_df)[endsWith(names(pure_and_mixed_df), "_scaled")]
    index_plot_cols <- c("ndvi", "ndwi_mf", "mndwi11", "mndwi12", "ndmi_gao11", "str1", "str2")
    cols_for_boxplotting <- c(scaled_s2_band_plot_cols, index_plot_cols[index_plot_cols %in% names(pure_and_mixed_df)])
    
    if(length(cols_for_boxplotting) > 0) {
      
      # 4. Reshape data from wide to long format for faceting.
      pure_and_mixed_long_df <- tidyr::pivot_longer(
        pure_and_mixed_df,
        cols = all_of(cols_for_boxplotting),
        names_to = "variable_name",
        values_to = "value"
      )
      # Remove any non-finite values (NA, Inf) that would cause errors.
      pure_and_mixed_long_df <- pure_and_mixed_long_df[is.finite(pure_and_mixed_long_df$value), ]
      
      # 5. Check for the custom color definition.
      if (!exists("main_label_colors")) {
        message("    [WARN] 'main_label_colors' vector not found. Using default ggplot2 colors.")
        main_label_colors <- NULL 
      } else {
        names(main_label_colors) <- tolower(names(main_label_colors))
      }
      
      # 6. Generate the plot.
      if(nrow(pure_and_mixed_long_df) > 0) {
        message("    Generating faceted boxplots for the combined data...")
        boxplot_collection_combined <- ggplot(pure_and_mixed_long_df, aes(x = dominant_label, y = value, fill = dominant_label)) +
          geom_boxplot() +
          facet_wrap(~ variable_name, scales = "free_y") +
          labs(
            title = "Distribution of S2 Bands & Indices for 'Pure' and 'Mixed' Labels",
            subtitle = paste("Site:", study_site_name, "| Year:", study_year),
            x = "Dominant Label (Mixture: Pure & Mixed Combined)",
            y = "Value (Scaled Reflectance or Index)"
          ) +
          theme_bw() +
          theme(
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
            plot.subtitle = element_text(hjust = 0.5),
            strip.text = element_text(face = "bold"),
            legend.position = "right"
          )
        
        # Apply custom colors if the color map was found.
        if (!is.null(main_label_colors)) {
          boxplot_collection_combined <- boxplot_collection_combined + 
            scale_fill_manual(
              name = "Dominant Label",
              values = main_label_colors
            )
        }
        
        print(boxplot_collection_combined)
        message("--> Boxplots for combined 'pure' and 'mixed' pixels generated successfully. ✅")
        
        # 7. Save the plot to a file.
        plot_output_dir <- file.path(output_root_dir, "boxplots", study_site_name, study_year)
        if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
        plot_filepath <- file.path(plot_output_dir, paste0(study_site_name, "_", study_year, "_boxplot_pure_and_mixed.png"))
        
        tryCatch({
          ggsave(plot_filepath, plot = boxplot_collection_combined, width = 14, height = 10, dpi = 300)
          message("    Boxplot saved to: ", plot_filepath)
        }, error = function(e) { message("[WARN] Could not save boxplot: ", e$message) })
      }
    }
  }
}


# --- 3.4: Generate Boxplots for "Pure" AND "Mixed" AND "Very Mixed" Pixel Categories ---
message("\n--> Generating boxplots for all pixel categories combined...")

# Prerequisite: Check if the necessary data frame and columns are available.
if (!exists("pixel_data_df") || !all(c("mixture_category", "dominant_label") %in% names(pixel_data_df))) {
  message("    [WARN] 'pixel_data_df' with required label columns not found. Skipping plot.")
} else {
  
  # 1. Use the full data frame, only removing pixels where a label could not be assigned.
  message("    Using all pixels with a valid dominant label for visualization...")
  all_pixels_df <- pixel_data_df[!is.na(pixel_data_df$dominant_label), ]
  
  if (nrow(all_pixels_df) == 0) {
    message("    [INFO] No pixels with valid labels found to plot.")
  } else {
    message("    Found ", format(nrow(all_pixels_df), big.mark=","), " pixels for this combined visualization.")
    
    # 2. Prepare data for plotting by setting a custom order for the x-axis.
    message("    Setting custom order for plot axis...")
    
    # Define your desired order for the labels on the axis.
    manual_order <- c('inundated', 'not inundated', 'other', 'uncertain')
    
    # Use only the levels present in this dataset.
    levels_present_in_data <- intersect(manual_order, unique(all_pixels_df$dominant_label))
    
    # Append any other existing labels to the end of the order.
    unordered_labels <- setdiff(unique(all_pixels_df$dominant_label), levels_present_in_data)
    final_plot_order <- c(levels_present_in_data, unordered_labels)
    all_pixels_df$dominant_label <- factor(all_pixels_df$dominant_label, levels = final_plot_order)
    
    # 3. Identify all numeric attributes to be plotted.
    scaled_s2_band_plot_cols <- names(all_pixels_df)[endsWith(names(all_pixels_df), "_scaled")]
    index_plot_cols <- c("ndvi", "ndwi_mf", "mndwi11", "mndwi12", "ndmi_gao11", "str1", "str2")
    cols_for_boxplotting <- c(scaled_s2_band_plot_cols, index_plot_cols[index_plot_cols %in% names(all_pixels_df)])
    
    if(length(cols_for_boxplotting) > 0) {
      
      # 4. Reshape data from wide to long format for faceting.
      all_pixels_long_df <- tidyr::pivot_longer(
        all_pixels_df,
        cols = all_of(cols_for_boxplotting),
        names_to = "variable_name",
        values_to = "value"
      )
      # Remove any non-finite values (NA, Inf) that would cause errors.
      all_pixels_long_df <- all_pixels_long_df[is.finite(all_pixels_long_df$value), ]
      
      # 5. Check for the custom color definition.
      if (!exists("main_label_colors")) {
        message("    [WARN] 'main_label_colors' vector not found. Using default ggplot2 colors.")
        main_label_colors <- NULL 
      } else {
        names(main_label_colors) <- tolower(names(main_label_colors))
      }
      
      # 6. Generate the plot.
      if(nrow(all_pixels_long_df) > 0) {
        message("    Generating faceted boxplots for all pixels...")
        boxplot_collection_all <- ggplot(all_pixels_long_df, aes(x = dominant_label, y = value, fill = dominant_label)) +
          geom_boxplot() +
          facet_wrap(~ variable_name, scales = "free_y") +
          labs(
            title = "Distribution of S2 Bands & Indices for All Pixels",
            subtitle = paste("Site:", study_site_name, "| Year:", study_year),
            x = "Dominant Label (All Mixture Levels Combined)",
            y = "Value (Scaled Reflectance or Index)"
          ) +
          theme_bw() +
          theme(
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
            plot.subtitle = element_text(hjust = 0.5),
            strip.text = element_text(face = "bold"),
            legend.position = "right"
          )
        
        # Apply custom colors if the color map was found.
        if (!is.null(main_label_colors)) {
          boxplot_collection_all <- boxplot_collection_all + 
            scale_fill_manual(
              name = "Dominant Label",
              values = main_label_colors
            )
        }
        
        print(boxplot_collection_all)
        message("--> Boxplots for all combined pixels generated successfully. ✅")
        
        # 7. Save the plot to a file.
        plot_output_dir <- file.path(output_root_dir, "boxplots", study_site_name, study_year)
        if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
        plot_filepath <- file.path(plot_output_dir, paste0(study_site_name, "_", study_year, "_boxplot_all_pixels_combined.png"))
        
        tryCatch({
          ggsave(plot_filepath, plot = boxplot_collection_all, width = 14, height = 10, dpi = 300)
          message("    Boxplot saved to: ", plot_filepath)
        }, error = function(e) { message("[WARN] Could not save boxplot: ", e$message) })
      }
    }
  }
}


## Part 4: Apply Decision Tree Model
# ==============================================================================
message("\nPart 4: Applying Pre-trained Decision Tree Model...")

# --- 4.1: Load the Model ---
# Note: The path to the model is assumed to be relative to your project directory.
model_rdata_path <- "source/jussila_decisiontree.RData"
model_env <- new.env()
if (!file.exists(model_rdata_path)) stop(paste("Model file not found at:", model_rdata_path))

message("--> Loading decision tree model from: ", model_rdata_path)
loaded_object_names <- load(model_rdata_path, envir = model_env)
if (length(loaded_object_names) == 0) stop("No objects loaded from the .RData file.")

model_object_name_in_file <- "tree_jussila"
if (model_object_name_in_file %in% loaded_object_names) {
  loaded_decision_tree <- model_env[[model_object_name_in_file]]
  message("    Successfully assigned model object '", model_object_name_in_file, "'.")
} else {
  stop(paste("Model object '", model_object_name_in_file, "' not found in the loaded .RData file."))
}

# --- 4.2: Prepare Data and Make Predictions ---
# The model requires specific predictor columns. These are now lowercase.
predictor_cols <- c("ndvi", "ndwi_mf", "mndwi11", "mndwi12", "ndmi_gao11")
missing_predictors <- predictor_cols[!(predictor_cols %in% names(pixel_data_df))]
if (length(missing_predictors) > 0) {
  stop(paste("The following predictor columns required by the model are missing:", paste(missing_predictors, collapse=", ")))
}
data_for_prediction <- pixel_data_df[, predictor_cols, drop = FALSE]

message("--> Making predictions using the loaded decision tree...")
tryCatch({
  # For 'rpart' models, type="class" gives the predicted class label.
  model_predictions <- predict(loaded_decision_tree, newdata = data_for_prediction, type = "class")
  
  # Add predictions as a new column to our main data frame.
  pixel_data_df$predicted_jussila <- model_predictions
  message("    Predictions added as a new column 'predicted_jussila'.")
}, error = function(e) {
  stop(paste("ERROR during model prediction:", e$message,
             "\nPlease ensure the correct package (e.g., 'rpart') for your model is loaded."))
})

# --- 4.3: Compare Predictions with Dominant Label ---
message("\n--> Comparing model predictions with the calculated dominant labels...")
# Note: 'dominant_label' column is already lowercase from Step 2.2.
if ("dominant_label" %in% names(pixel_data_df)) {
  message("    Confusion Matrix (Comparison):")
  
  # Ensure both columns are factors for a clean table
  actual_labels_factor <- as.factor(pixel_data_df$dominant_label)
  predicted_labels_factor <- as.factor(pixel_data_df$predicted_jussila)
  
  # The 'dnn' argument provides nice names for the table dimensions
  confusion_table <- table(Actual = actual_labels_factor, Predicted = predicted_labels_factor,
                           dnn=c("Dominant Label (Actual)", "Jussila Model (Predicted)"))
  print(confusion_table)
} else {
  message("[WARN] 'dominant_label' column not found, cannot create comparison table.")
}
message("--> Model application complete. ✅")
# --- End of Part 4 ---


message("\n--- Script processing finished. ---")
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#       Analysis and Modeling of Processed Pixel Data
#
# This script loads a pre-processed CSV file containing pixel attributes
# (coordinates, fractions, S2 bands, indices, and derived labels).
# It performs data summary, visualization (boxplots), and applies a
# pre-trained decision tree model to generate new predictions.
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


## Part 1: Setup & Configuration
# ==============================================================================
message("Part 1: Initializing Setup and Configuration...")

# --- 1.1: Load Required Packages ---
message("--> Loading required R packages: dplyr, ggplot2, tidyr")
# 'terra' is not strictly needed if only working with the data frame, but good practice.
# 'rpart' or other model packages may be needed for the predict() function to work.
if (!requireNamespace("dplyr", quietly = TRUE)) stop("Package 'dplyr' is required.")
if (!requireNamespace("ggplot2", quietly = TRUE)) stop("Package 'ggplot2' is required.")
if (!requireNamespace("tidyr", quietly = TRUE)) stop("Package 'tidyr' is required.")
if (!requireNamespace("sf", quietly = TRUE)) message("[INFO] 'sf' package not found, will not be used.")
library(dplyr)
library(ggplot2)
library(tidyr)
# library(rpart) # Example: You may need to load the package for your specific model

# --- 1.2: Source Utility and Configuration Files ---
message("--> Sourcing utility and configuration files...")
# Define paths to helper scripts.
gdrive_utils_path <- "source/gdrive_utils.R"
spatial_utils_path <- "source/spatial_processing_utils.R"
config_path <- "source/config.R"

# Helper function to source files safely.
source_if_exists <- function(file_path, file_description) {
  if (!file.exists(file_path)) {
    stop(paste(file_description, "not found at:", normalizePath(file_path, mustWork = FALSE)))
  }
  message("    Sourcing ", file_description, " from: ", normalizePath(file_path))
  source(file_path, local = FALSE, chdir = TRUE)
}

# Source the files. This loads project-specific variables from config.R.
source_if_exists(gdrive_utils_path, "Google Drive utilities (gdrive_utils.R)")
source_if_exists(config_path, "Configuration settings (config.R)")
source_if_exists(spatial_utils_path, "Spatial processing utilities (spatial_processing_utils.R)")

# --- 1.3: Define Input File Path from Configuration ---
message("--> Defining input CSV file path...")
# This path should point to the CSV file generated by the previous script.
# The user specified this exact filename.
input_csv_filename <- paste0(study_site_name, "_", study_year, "_pixel_data_S2_and_fractions.csv")
# This assumes the CSV is in a 'pixel_data_tables' subdirectory. Adjust if needed.
input_csv_directory <- file.path(output_root_dir, "fraction rasters", study_site_name, study_year)
input_csv_path <- file.path(input_csv_directory, input_csv_filename)
message("    Expected path for input CSV: ", input_csv_path)

message("--> Setup and configuration complete. ✅")
# --- End of Part 1 ---


## Part 2: Load and Prepare Data
# ==============================================================================
message("\nPart 2: Loading and Preparing Pixel Data from CSV...")

# --- 2.1: Load the CSV File ---
if (!file.exists(input_csv_path)) {
  stop(paste("Input CSV file not found:", input_csv_path,
             "\nPlease ensure the path and filename are correct and the previous script has been run successfully."))
}
message("--> Loading data from: ", input_csv_path)
tryCatch({
  # Using read.csv from base R. For very large files, consider data.table::fread()
  pixel_data_df <- read.csv(input_csv_path, stringsAsFactors = TRUE) # stringsAsFactors=TRUE helps with label columns
  message("    Successfully loaded ", format(nrow(pixel_data_df), big.mark=","), " pixels with ", ncol(pixel_data_df), " attributes.")
  message("    Initial columns in loaded data frame:")
  print(names(pixel_data_df))
}, error = function(e) {
  stop(paste("Error loading CSV file:", e$message))
})

 # --- 2.2: Standardize Column Names to Lowercase ---
# Your original script standardized names to lowercase, which is important for
# consistency, especially when the model expects specific (e.g., lowercase) predictor names.
message("--> Converting all column names to lowercase for consistency...")
names(pixel_data_df) <- tolower(names(pixel_data_df))
message("    Column names after lowercasing:")
print(names(pixel_data_df))
message("--> Data loaded and prepared successfully. ✅")
# --- End of Part 2 ---


## Part 3: Data Summary & Visualization
# ==============================================================================
message("\nPart 3: Data Summary and Visualization...")

# --- 3.1: Summarize Pixel Counts by Category ---
message("--> Summarizing pixel counts by category...")
# Note: The 'dominant_label' and 'mixture_category' columns are now lowercase.
if ("mixture_category" %in% names(pixel_data_df)) {
  message("    Counts per 'mixture_category':")
  print(table(pixel_data_df$mixture_category, dnn = "Mixture Category"))
}
if ("dominant_label" %in% names(pixel_data_df)) {
  message("\n    Counts per 'dominant_label':")
  print(table(pixel_data_df$dominant_label, dnn = "Dominant Label"))
}

# --- 3.2: Summarize Pixel Counts as a Pivot Table ---
message("--> Summarizing pixel counts in a pivot table...")

# Note: The 'dominant_label' and 'mixture_category' columns were converted to lowercase in Part 2.
if (!all(c("dominant_label", "mixture_category") %in% names(pixel_data_df))) {
  message("[WARN] 'dominant_label' and/or 'mixture_category' columns not found. Skipping pivot table summary.")
} else {
  
  message("    Generating pivot table: 'dominant_label' (rows) vs. 'mixture_category' (columns)...")
  
  # To ensure a logical column order (pure, mixed, very_mixed), we can convert
  # the 'mixture_category' column to a factor with a specified level order.
  mixture_levels_order <- c("pure", "mixed", "very_mixed")
  # We only use levels that are actually present in the data to avoid empty columns.
  actual_levels_in_data <- intersect(mixture_levels_order, unique(pixel_data_df$mixture_category))
  
  if (length(actual_levels_in_data) > 0) {
    # Temporarily create an ordered factor for tabulation
    mixture_category_ordered <- factor(pixel_data_df$mixture_category, levels = actual_levels_in_data)
    
    # Create the two-way contingency table (the pivot table)
    pivot_table_counts <- table(
      `Dominant Label` = pixel_data_df$dominant_label, 
      `Mixture Category` = mixture_category_ordered
    )
    
    # Use addmargins() to add row and column totals, which are labeled "Sum"
    pivot_table_with_totals <- addmargins(pivot_table_counts)
    
    message("\n    --- Pixel Count Summary: Dominant Label vs. Mixture Category ---")
    print(pivot_table_with_totals)
    message("    ------------------------------------------------------------------\n")
    
  } else {
    # Fallback in case the standard category names aren't found
    message("[WARN] No standard mixture categories ('pure', 'mixed', 'very_mixed') found. Printing a simple table without totals.")
    print(table(pixel_data_df$dominant_label, pixel_data_df$mixture_category))
  }
}

# --- 3.3: Create Stacked Bar Plot of Pixel Counts by Label and Mixture ---
message("\n--> Generating a stacked horizontal bar plot for pixel counts...")

# Check if the necessary columns exist
if (!all(c("dominant_label", "mixture_category") %in% names(pixel_data_df))) {
  message("[WARN] 'dominant_label' and/or 'mixture_category' columns not found. Skipping plot.")
} else {
  
  # 1. Prepare data for plotting by counting each combination
  plot_data <- pixel_data_df %>%
    filter(!is.na(dominant_label) & !is.na(mixture_category)) %>%
    count(dominant_label, mixture_category, name = "pixel_count")
  
  if (nrow(plot_data) == 0) {
    message("    [INFO] No data available to plot after filtering for non-NA labels.")
  } else {
    
    # 2. Define the color palette for the dominant labels
    main_label_colors <- c(
      "inundated" = "#4cd2de",
      "not inundated" = "#dc5199",
      "other" = "#86eb79",
      "uncertain" = "#ff7f00"
    )
    
    # 3. Prepare data for plotting: order factors
    # Order mixture_category to stack pure -> mixed -> very_mixed from left to right.
    # To do this, the factor levels must be in the REVERSE order.
    plot_data$mixture_category <- factor(
      plot_data$mixture_category, 
      levels = c("very_mixed", "mixed", "pure") 
    )
    
    # Order dominant_label bars from longest to shortest
    label_totals <- plot_data %>%
      group_by(dominant_label) %>%
      summarize(total_count = sum(pixel_count)) %>%
      arrange(total_count)
    
    plot_data$dominant_label <- factor(
      plot_data$dominant_label, 
      levels = label_totals$dominant_label
    )
    
    # Calculate text label positions to match the stacking order
    plot_data <- plot_data %>%
      arrange(dominant_label, desc(mixture_category)) %>%
      group_by(dominant_label) %>%
      mutate(
        label_position = cumsum(pixel_count) - 0.5 * pixel_count,
        total_pixels_in_bar = sum(pixel_count)
      )
    
    # 4. Create the stacked horizontal bar plot
    message("    Generating plot with reversed legend order...")
    stacked_bar_plot <- ggplot(plot_data,
                               aes(y = dominant_label, x = pixel_count, fill = dominant_label)) +
      # Use alpha aesthetic to create shades based on mixture_category
      geom_col(aes(alpha = mixture_category)) +
      
      # Apply the main colors for each dominant_label
      scale_fill_manual(
        name = "Dominant Label", # Set title for the color legend
        values = main_label_colors
      ) +
      
      # Manually define the transparency levels for each mixture category
      scale_alpha_manual(
        name = "Mixture Level", # Set title for the transparency legend
        values = c(
          "pure" = 1.0,         # Fully opaque
          "mixed" = 0.7,        # Partially transparent
          "very_mixed" = 0.4    # More transparent
        ),
        breaks = c("pure", "mixed", "very_mixed"),
        labels = c("Pure (>=90%)", "Mixed (60-90%)", "Very Mixed (<=60%)")
      ) +
      
      # Add text labels for the counts on the bars
      geom_text(
        aes(x = label_position, label = pixel_count),
        data = . %>% filter(pixel_count / total_pixels_in_bar > 0.05),
        size = 3.5, color = "white", fontface = "bold"
      ) +
      
      # Customize labels and theme
      labs(
        title = "Pixel Count by Dominant Label and Mixture Level",
        subtitle = if(exists("study_site_name")) paste("Site:", study_site_name, "| Year:", study_year) else "",
        x = "Number of Pixels",
        y = "Dominant Label"
      ) +
      theme_classic() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.line = element_line(colour = "black"),
        axis.ticks = element_line(colour = "black"),
        legend.position = "top",
        legend.box = "vertical"
      ) +
      
      # This 'guides' function tells ggplot how to draw the legends.
      guides(
        # Reverse the order of the fill legend to match the plot's top-to-bottom order.
        fill = guide_legend(reverse = TRUE),
        
        # Keep the customization for the alpha legend.
        alpha = guide_legend(
          override.aes = list(fill = "grey50") # This makes the alpha legend swatches shades of grey
        )
      )
    
    # Print the final plot
    print(stacked_bar_plot)
    message("--> Stacked horizontal bar plot with corrected legend order generated successfully. ✅")
    
    # Save the plot
    plot_output_dir <- file.path(output_root_dir, "plots", study_site_name, study_year)
    if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
    plot_filepath <- file.path(plot_output_dir, paste0(study_site_name, "_", study_year, "_stacked_bar_plot.png"))
    
    tryCatch({
      ggsave(plot_filepath, plot = stacked_bar_plot, width = 10, height = 8, dpi = 300)
      message("    Plot saved to: ", plot_filepath)
    }, error = function(e) { message("[WARN] Could not save plot: ", e$message) })
    
  } # End if(nrow(plot_data) > 0)
} # End if(all columns exist)
message("--> Data summary and visualization complete. ✅")


# --- 3.2: Generate Boxplots for "Pure" Pixels ---
message("\n--> Generating boxplots to visualize attribute distributions for 'pure' pixels...")

# Prerequisite: Check if the necessary data frame and columns are available.
if (!exists("pixel_data_df") || !all(c("mixture_category", "dominant_label") %in% names(pixel_data_df))) {
  message("    [INFO] 'pixel_data_df' with required label columns not found. Skipping plot.")
} else {
  
  # 1. Filter data to include only pixels classified as "pure"
  pure_labels_df <- pixel_data_df[which(pixel_data_df$mixture_category == "pure"), ]
  
  if (nrow(pure_labels_df) == 0) {
    message("    [INFO] No 'pure' pixels found in the data to plot.")
  } else {
    message("    Found ", format(nrow(pure_labels_df), big.mark=","), " 'pure' pixels for visualization.")
    
    # 2. Prepare data for plotting by setting a custom order for the x-axis
    message("    Setting custom order for plot axis...")
    
    # Define the desired order for the labels on the axis.
    manual_order <- c('inundated', 'not inundated', 'other', 'uncertain')
    
    # Identify which of these desired labels are actually present in the current data.
    levels_present_in_data <- intersect(manual_order, unique(pure_labels_df$dominant_label))
    
    # Re-level the dominant_label column. This ensures the plot axis follows your manual order.
    # Any labels in the data but not in 'manual_order' will appear at the end.
    if(length(levels_present_in_data) > 0) {
      unordered_labels <- setdiff(unique(pure_labels_df$dominant_label), levels_present_in_data)
      final_plot_order <- c(levels_present_in_data, unordered_labels)
      pure_labels_df$dominant_label <- factor(pure_labels_df$dominant_label, levels = final_plot_order)
    }
    
    # 3. Identify all numeric attributes to be plotted
    # a) Scaled Sentinel-2 bands (columns ending with '_scaled')
    scaled_s2_band_plot_cols <- names(pure_labels_df)[
      startsWith(names(pure_labels_df), "b") & endsWith(names(pure_labels_df), "_scaled")
    ]
    # b) Spectral Index columns
    index_plot_cols <- c("ndvi", "ndwi_mf", "mndwi11", "mndwi12", "ndmi_gao11", "str1", "str2")
    index_plot_cols_exist <- index_plot_cols[index_plot_cols %in% names(pure_labels_df)]
    
    cols_for_boxplotting <- c(scaled_s2_band_plot_cols, index_plot_cols_exist)
    
    if (length(cols_for_boxplotting) == 0) {
      message("    [WARN] No scaled S2 band or spectral index columns identified for plotting.")
    } else {
      message("    Variables selected for plotting: ", paste(cols_for_boxplotting, collapse=", "))
      
      # 4. Reshape data from a wide to a long format, which is required for faceting in ggplot
      pure_labels_long_df <- tidyr::pivot_longer(
        pure_labels_df,
        cols = all_of(cols_for_boxplotting),
        names_to = "variable_name",
        values_to = "value"
      )
      # Remove any non-finite values (NA, Inf) that would cause errors in plotting
      pure_labels_long_df <- pure_labels_long_df[is.finite(pure_labels_long_df$value), ]
      
      # 5. Check for the custom color definition
      if (!exists("main_label_colors")) {
        message("    [WARN] 'main_label_colors' vector not found. Using default ggplot2 colors.")
        main_label_colors <- NULL 
      } else {
        names(main_label_colors) <- tolower(names(main_label_colors))
      }
      
      # 6. Generate the final plot
      if(nrow(pure_labels_long_df) > 0) {
        message("    Generating faceted boxplots...")
        boxplot_collection <- ggplot(pure_labels_long_df, aes(x = dominant_label, y = value, fill = dominant_label)) +
          geom_boxplot() +
          facet_wrap(~ variable_name, scales = "free_y") +
          labs(
            title = "Distribution of S2 Bands & Indices for 'Pure' Dominant Labels",
            subtitle = paste("Site:", study_site_name, "| Year:", study_year),
            x = "Dominant Label (Mixture Category: Pure)",
            y = "Value (Scaled Reflectance or Index)"
          ) +
          theme_bw() +
          theme(
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
            plot.subtitle = element_text(hjust = 0.5),
            strip.text = element_text(face = "bold"),
            legend.position = "right" # Ensures the legend is visible
          )
        
        # Apply custom colors only if the color map was found and is valid
        if (!is.null(main_label_colors)) {
          boxplot_collection <- boxplot_collection + scale_fill_manual(
            name = "Dominant Label", # Sets the title for the legend
            values = main_label_colors
          )
        }
        
        print(boxplot_collection)
        message("--> Boxplots generated successfully. ✅")
        
        # 7. Save the plot to a file
        plot_output_dir <- file.path(output_root_dir, "boxplots", study_site_name, study_year)
        if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
        plot_filepath <- file.path(plot_output_dir, paste0(study_site_name, "_", study_year, "_boxplot_pure_labels.png"))
        
        tryCatch({
          ggsave(plot_filepath, plot = boxplot_collection, width = 14, height = 10, dpi = 300)
          message("    Boxplot saved to: ", plot_filepath)
        }, error = function(e) { message("[WARN] Could not save boxplot: ", e$message) })
      } else {
        message("    [INFO] No data available for plotting after filtering and reshaping.")
      }
    }
  }
}

# --- 3.3: Generate Boxplots for "Pure" AND "Mixed" Pixel Categories ---
message("\n--> Generating boxplots for combined 'pure' and 'mixed' pixel categories...")

# Prerequisite: Check if the necessary data frame and columns are available.
if (!exists("pixel_data_df") || !all(c("mixture_category", "dominant_label") %in% names(pixel_data_df))) {
  message("    [WARN] 'pixel_data_df' with required label columns not found. Skipping plot.")
} else {
  
  # 1. Filter data to select all pixels where mixture_category is either "pure" or "mixed".
  message("    Filtering data to select all 'pure' and 'mixed' pixels...")
  pure_and_mixed_df <- pixel_data_df[
    which(pixel_data_df$mixture_category %in% c("pure", "mixed")), 
  ]
  
  if (nrow(pure_and_mixed_df) == 0) {
    message("    [INFO] No 'pure' or 'mixed' pixels found in the data to plot.")
  } else {
    message("    Found ", format(nrow(pure_and_mixed_df), big.mark=","), " pixels for this combined visualization.")
    
    # 2. Prepare data for plotting by setting a custom order for the x-axis.
    message("    Setting custom order for plot axis...")
    
    # Define the desired order for the labels on the axis.
    manual_order <- c('inundated', 'not inundated', 'other', 'uncertain')
    
    # Use only the levels present in this specific filtered dataset.
    levels_present_in_data <- intersect(manual_order, unique(pure_and_mixed_df$dominant_label))
    
    # Append any other existing labels to the end of the order.
    unordered_labels <- setdiff(unique(pure_and_mixed_df$dominant_label), levels_present_in_data)
    final_plot_order <- c(levels_present_in_data, unordered_labels)
    pure_and_mixed_df$dominant_label <- factor(pure_and_mixed_df$dominant_label, levels = final_plot_order)
    
    # 3. Identify all numeric attributes to be plotted.
    scaled_s2_band_plot_cols <- names(pure_and_mixed_df)[endsWith(names(pure_and_mixed_df), "_scaled")]
    index_plot_cols <- c("ndvi", "ndwi_mf", "mndwi11", "mndwi12", "ndmi_gao11", "str1", "str2")
    cols_for_boxplotting <- c(scaled_s2_band_plot_cols, index_plot_cols[index_plot_cols %in% names(pure_and_mixed_df)])
    
    if(length(cols_for_boxplotting) > 0) {
      
      # 4. Reshape data from wide to long format for faceting.
      pure_and_mixed_long_df <- tidyr::pivot_longer(
        pure_and_mixed_df,
        cols = all_of(cols_for_boxplotting),
        names_to = "variable_name",
        values_to = "value"
      )
      # Remove any non-finite values (NA, Inf) that would cause errors.
      pure_and_mixed_long_df <- pure_and_mixed_long_df[is.finite(pure_and_mixed_long_df$value), ]
      
      # 5. Check for the custom color definition.
      if (!exists("main_label_colors")) {
        message("    [WARN] 'main_label_colors' vector not found. Using default ggplot2 colors.")
        main_label_colors <- NULL 
      } else {
        names(main_label_colors) <- tolower(names(main_label_colors))
      }
      
      # 6. Generate the plot.
      if(nrow(pure_and_mixed_long_df) > 0) {
        message("    Generating faceted boxplots for the combined data...")
        boxplot_collection_combined <- ggplot(pure_and_mixed_long_df, aes(x = dominant_label, y = value, fill = dominant_label)) +
          geom_boxplot() +
          facet_wrap(~ variable_name, scales = "free_y") +
          labs(
            title = "Distribution of S2 Bands & Indices for 'Pure' and 'Mixed' Labels",
            subtitle = paste("Site:", study_site_name, "| Year:", study_year),
            x = "Dominant Label (Mixture: Pure & Mixed Combined)",
            y = "Value (Scaled Reflectance or Index)"
          ) +
          theme_bw() +
          theme(
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
            plot.subtitle = element_text(hjust = 0.5),
            strip.text = element_text(face = "bold"),
            legend.position = "right"
          )
        
        # Apply custom colors if the color map was found.
        if (!is.null(main_label_colors)) {
          boxplot_collection_combined <- boxplot_collection_combined + 
            scale_fill_manual(
              name = "Dominant Label",
              values = main_label_colors
            )
        }
        
        print(boxplot_collection_combined)
        message("--> Boxplots for combined 'pure' and 'mixed' pixels generated successfully. ✅")
        
        # 7. Save the plot to a file.
        plot_output_dir <- file.path(output_root_dir, "boxplots", study_site_name, study_year)
        if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
        plot_filepath <- file.path(plot_output_dir, paste0(study_site_name, "_", study_year, "_boxplot_pure_and_mixed.png"))
        
        tryCatch({
          ggsave(plot_filepath, plot = boxplot_collection_combined, width = 14, height = 10, dpi = 300)
          message("    Boxplot saved to: ", plot_filepath)
        }, error = function(e) { message("[WARN] Could not save boxplot: ", e$message) })
      }
    }
  }
}


# --- 3.4: Generate Boxplots for "Pure" AND "Mixed" AND "Very Mixed" Pixel Categories ---
message("\n--> Generating boxplots for all pixel categories combined...")

# Prerequisite: Check if the necessary data frame and columns are available.
if (!exists("pixel_data_df") || !all(c("mixture_category", "dominant_label") %in% names(pixel_data_df))) {
  message("    [WARN] 'pixel_data_df' with required label columns not found. Skipping plot.")
} else {
  
  # 1. Use the full data frame, only removing pixels where a label could not be assigned.
  message("    Using all pixels with a valid dominant label for visualization...")
  all_pixels_df <- pixel_data_df[!is.na(pixel_data_df$dominant_label), ]
  
  if (nrow(all_pixels_df) == 0) {
    message("    [INFO] No pixels with valid labels found to plot.")
  } else {
    message("    Found ", format(nrow(all_pixels_df), big.mark=","), " pixels for this combined visualization.")
    
    # 2. Prepare data for plotting by setting a custom order for the x-axis.
    message("    Setting custom order for plot axis...")
    
    # Define your desired order for the labels on the axis.
    manual_order <- c('inundated', 'not inundated', 'other', 'uncertain')
    
    # Use only the levels present in this dataset.
    levels_present_in_data <- intersect(manual_order, unique(all_pixels_df$dominant_label))
    
    # Append any other existing labels to the end of the order.
    unordered_labels <- setdiff(unique(all_pixels_df$dominant_label), levels_present_in_data)
    final_plot_order <- c(levels_present_in_data, unordered_labels)
    all_pixels_df$dominant_label <- factor(all_pixels_df$dominant_label, levels = final_plot_order)
    
    # 3. Identify all numeric attributes to be plotted.
    scaled_s2_band_plot_cols <- names(all_pixels_df)[endsWith(names(all_pixels_df), "_scaled")]
    index_plot_cols <- c("ndvi", "ndwi_mf", "mndwi11", "mndwi12", "ndmi_gao11", "str1", "str2")
    cols_for_boxplotting <- c(scaled_s2_band_plot_cols, index_plot_cols[index_plot_cols %in% names(all_pixels_df)])
    
    if(length(cols_for_boxplotting) > 0) {
      
      # 4. Reshape data from wide to long format for faceting.
      all_pixels_long_df <- tidyr::pivot_longer(
        all_pixels_df,
        cols = all_of(cols_for_boxplotting),
        names_to = "variable_name",
        values_to = "value"
      )
      # Remove any non-finite values (NA, Inf) that would cause errors.
      all_pixels_long_df <- all_pixels_long_df[is.finite(all_pixels_long_df$value), ]
      
      # 5. Check for the custom color definition.
      if (!exists("main_label_colors")) {
        message("    [WARN] 'main_label_colors' vector not found. Using default ggplot2 colors.")
        main_label_colors <- NULL 
      } else {
        names(main_label_colors) <- tolower(names(main_label_colors))
      }
      
      # 6. Generate the plot.
      if(nrow(all_pixels_long_df) > 0) {
        message("    Generating faceted boxplots for all pixels...")
        boxplot_collection_all <- ggplot(all_pixels_long_df, aes(x = dominant_label, y = value, fill = dominant_label)) +
          geom_boxplot() +
          facet_wrap(~ variable_name, scales = "free_y") +
          labs(
            title = "Distribution of S2 Bands & Indices for All Pixels",
            subtitle = paste("Site:", study_site_name, "| Year:", study_year),
            x = "Dominant Label (All Mixture Levels Combined)",
            y = "Value (Scaled Reflectance or Index)"
          ) +
          theme_bw() +
          theme(
            axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10),
            plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
            plot.subtitle = element_text(hjust = 0.5),
            strip.text = element_text(face = "bold"),
            legend.position = "right"
          )
        
        # Apply custom colors if the color map was found.
        if (!is.null(main_label_colors)) {
          boxplot_collection_all <- boxplot_collection_all + 
            scale_fill_manual(
              name = "Dominant Label",
              values = main_label_colors
            )
        }
        
        print(boxplot_collection_all)
        message("--> Boxplots for all combined pixels generated successfully. ✅")
        
        # 7. Save the plot to a file.
        plot_output_dir <- file.path(output_root_dir, "boxplots", study_site_name, study_year)
        if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
        plot_filepath <- file.path(plot_output_dir, paste0(study_site_name, "_", study_year, "_boxplot_all_pixels_combined.png"))
        
        tryCatch({
          ggsave(plot_filepath, plot = boxplot_collection_all, width = 14, height = 10, dpi = 300)
          message("    Boxplot saved to: ", plot_filepath)
        }, error = function(e) { message("[WARN] Could not save boxplot: ", e$message) })
      }
    }
  }
}


## Part 4: Apply Decision Tree Model
# ==============================================================================
message("\nPart 4: Applying Pre-trained Decision Tree Model...")

# --- 4.1: Load the Model ---
# Note: The path to the model is assumed to be relative to your project directory.
model_rdata_path <- "source/jussila_decisiontree.RData"
model_env <- new.env()
if (!file.exists(model_rdata_path)) stop(paste("Model file not found at:", model_rdata_path))

message("--> Loading decision tree model from: ", model_rdata_path)
loaded_object_names <- load(model_rdata_path, envir = model_env)
if (length(loaded_object_names) == 0) stop("No objects loaded from the .RData file.")

model_object_name_in_file <- "tree_jussila"
if (model_object_name_in_file %in% loaded_object_names) {
  loaded_decision_tree <- model_env[[model_object_name_in_file]]
  message("    Successfully assigned model object '", model_object_name_in_file, "'.")
} else {
  stop(paste("Model object '", model_object_name_in_file, "' not found in the loaded .RData file."))
}

# --- 4.1a: Programmatically Identify Model Predictors ---
message("--> Inspecting the loaded model object to identify required predictors...")

# The model object stores the names of the variables it was trained on.
# We can access them through the 'terms' attribute.
# This avoids the printing error and gives us the exact list.
required_predictors_from_model <- NULL
if (inherits(loaded_decision_tree, "rpart")) {
  if (!is.null(loaded_decision_tree$terms)) {
    # 'term.labels' attribute contains the predictor names
    required_predictors_from_model <- attr(loaded_decision_tree$terms, "term.labels")
  }
}

if (is.null(required_predictors_from_model) || length(required_predictors_from_model) == 0) {
  message("[WARN] Could not automatically determine predictors. Will fall back to manual list.")
  # Define the list manually as a fallback
  predictor_cols <- c("ndvi", "ndwi_mf", "mndwi11", "mndwi12", "ndmi_gao11")
  # You would have to manually add 'b02', etc. to this list.
} else {
  message("    Predictors required by the model have been identified automatically:")
  print(required_predictors_from_model)
  # Use this automatically generated list for prediction
  predictor_cols <- required_predictors_from_model
}

# --- 4.2: Prepare Data and Make Predictions ---
missing_predictors <- predictor_cols[!(predictor_cols %in% names(pixel_data_df))]
if (length(missing_predictors) > 0) {
  stop(paste("The following predictor columns required by the model are missing:", paste(missing_predictors, collapse=", ")))
}
data_for_prediction <- pixel_data_df[, predictor_cols, drop = FALSE]

message("--> Making predictions using the loaded decision tree...")
tryCatch({
  # For 'rpart' models, type="class" gives the predicted class label.
  model_predictions <- predict(loaded_decision_tree, newdata = data_for_prediction, type = "class")
  
  # Add predictions as a new column to our main data frame.
  pixel_data_df$predicted_jussila <- model_predictions
  message("    Predictions added as a new column 'predicted_jussila'.")
}, error = function(e) {
  stop(paste("ERROR during model prediction:", e$message,
             "\nPlease ensure the correct package (e.g., 'rpart') for your model is loaded."))
})

# --- 4.3: Compare Predictions with Dominant Label ---
message("\n--> Comparing model predictions with the calculated dominant labels...")
# Note: 'dominant_label' column is already lowercase from Step 2.2.
if ("dominant_label" %in% names(pixel_data_df)) {
  message("    Confusion Matrix (Comparison):")
  
  # Ensure both columns are factors for a clean table
  actual_labels_factor <- as.factor(pixel_data_df$dominant_label)
  predicted_labels_factor <- as.factor(pixel_data_df$predicted_jussila)
  
  # The 'dnn' argument provides nice names for the table dimensions
  confusion_table <- table(Actual = actual_labels_factor, Predicted = predicted_labels_factor,
                           dnn=c("Dominant Label (Actual)", "Jussila Model (Predicted)"))
  print(confusion_table)
} else {
  message("[WARN] 'dominant_label' column not found, cannot create comparison table.")
}
message("--> Model application complete. ✅")


# --- Calculate Recall, Precision, AND F1 Score by Mixture Level ---
message("\n--> Calculating recall, precision, and F1 score, subdivided by mixture level...")

# Prerequisites: Check if the necessary data frame and columns are available.
if (!exists("pixel_data_df") || !all(c("dominant_label", "mixture_category", "predicted_jussila") %in% names(pixel_data_df))) {
  message("    [WARN] 'pixel_data_df' with required columns not found. Skipping metrics calculation.")
} else {
  
  # 1. Prepare data for evaluation
  message("    Preparing data for evaluation by mapping reference labels to 'water' and 'dry' classes...")
  evaluation_df <- pixel_data_df %>%
    mutate(reference_class = case_when(
      dominant_label == 'inundated' ~ 'water',
      dominant_label %in% c('not inundated', 'other') ~ 'dry',
      TRUE ~ NA_character_
    )) %>%
    filter(
      !is.na(reference_class),
      predicted_jussila %in% c('water', 'dry')
    )
  
  if (nrow(evaluation_df) == 0) {
    message("    [INFO] No data available for evaluation after filtering. Please check labels.")
  } else {
    
    # 2. Loop through each mixture level to calculate metrics
    mixture_levels_in_data <- unique(evaluation_df$mixture_category)
    results_list <- list()
    
    for (level in mixture_levels_in_data) {
      message(paste("    Calculating metrics for mixture level:", level))
      subset_df <- evaluation_df %>% filter(mixture_category == level)
      
      if (nrow(subset_df) > 0) {
        # --- Metrics for the "water" class ---
        TP_water <- sum(subset_df$reference_class == "water" & subset_df$predicted_jussila == "water")
        FP_water <- sum(subset_df$reference_class == "dry"   & subset_df$predicted_jussila == "water")
        FN_water <- sum(subset_df$reference_class == "water" & subset_df$predicted_jussila == "dry")
        recall_water <- ifelse((TP_water + FN_water) > 0, TP_water / (TP_water + FN_water), 0)
        precision_water <- ifelse((TP_water + FP_water) > 0, TP_water / (TP_water + FP_water), 0)
        f1_score_water <- ifelse((precision_water + recall_water) > 0, 2 * (precision_water * recall_water) / (precision_water + recall_water), 0)
        
        # --- Metrics for the "dry" class ---
        TP_dry <- sum(subset_df$reference_class == "dry"   & subset_df$predicted_jussila == "dry")
        FP_dry <- sum(subset_df$reference_class == "water" & subset_df$predicted_jussila == "dry")
        FN_dry <- sum(subset_df$reference_class == "dry"   & subset_df$predicted_jussila == "water")
        recall_dry <- ifelse((TP_dry + FN_dry) > 0, TP_dry / (TP_dry + FN_dry), 0)
        precision_dry <- ifelse((TP_dry + FP_dry) > 0, TP_dry / (TP_dry + FP_dry), 0)
        f1_score_dry <- ifelse((precision_dry + recall_dry) > 0, 2 * (precision_dry * recall_dry) / (precision_dry + recall_dry), 0)
        
        # Store results for this level
        level_results <- data.frame(
          class_of_interest = c("water", "dry"),
          recall = c(recall_water, recall_dry),
          precision = c(precision_water, precision_dry),
          f1_score = c(f1_score_water, f1_score_dry), # Added F1 Score
          support_actual = c(TP_water + FN_water, TP_dry + FN_dry)
        )
        results_list[[level]] <- level_results
      }
    }
    
    # 3. Combine and display the final summary table
    if (length(results_list) > 0) {
      final_summary_df <- dplyr::bind_rows(results_list, .id = "mixture_level")
      final_summary_df$mixture_level <- factor(final_summary_df$mixture_level, levels = c("pure", "mixed", "very_mixed"))
      
      final_summary_df <- final_summary_df %>%
        arrange(mixture_level, class_of_interest) %>%
        select(mixture_level, class_of_interest, recall, precision, f1_score, support_actual) %>%
        mutate(across(c(recall, precision, f1_score), ~round(.x, 3)))
      
      message("\n    --- Model Performance Summary (with F1 Score) by Mixture Level ---")
      print(final_summary_df, row.names = FALSE)
      message("    ---------------------------------------------------------------------\n")
    }
  }
}
message("--> Metrics calculation (including F1 score) complete. ✅")


# --- 4.4: Generate Line Plots for Model Performance Metrics ---
message("\n--> Generating line plots for recall, precision,and F1 score...")

# Prerequisite: Check if the final_summary_df from the metrics calculation exists.
if (!exists("final_summary_df") || !is.data.frame(final_summary_df)) {
  message("    [WARN] 'final_summary_df' not found. Skipping metrics plot.")
} else {
  
  # 1. Prepare data for plotting by reshaping it (this part remains the same)
  plot_data_metrics <- final_summary_df %>%
    select(mixture_level, class_of_interest, recall, precision, f1_score) %>%
    tidyr::pivot_longer(
      cols = c(recall, precision, f1_score),
      names_to = "metric_name",
      values_to = "metric_value"
    )
  
  # 2. Define colors to match your previous plots
  metric_plot_colors <- c(
    "water" = "#4cd2de",
    "dry" = "#dc5199"
  )
  
  # 3. Order factors for a clean plot layout
  # This ensures the x-axis and facets are in a logical order.
  plot_data_metrics$metric_name <- factor(plot_data_metrics$metric_name, levels = c("recall", "precision", "f1_score"))
  plot_data_metrics$mixture_level <- factor(plot_data_metrics$mixture_level, levels = c("pure", "mixed", "very_mixed"))
  
  # 4. Generate the faceted line plot
  message("    Generating faceted line plot...")
  metrics_line_plot <- ggplot(plot_data_metrics, 
                              aes(x = mixture_level, y = metric_value, 
                                  group = class_of_interest, # Tell ggplot which points to connect
                                  color = class_of_interest)) + # Color the lines by class
    
    # Add the lines to show the trend
    geom_line(linewidth = 1.2) +
    
    # Add points to mark the exact values at each mixture level
    geom_point(size = 3.5, stroke = 1.5, aes(shape = class_of_interest)) +
    
    # Create the three separate panels for recall, precision, and f1_score
    facet_wrap(~ metric_name) +
    
    # Add the numeric value label near each point for clarity
    geom_text(
      aes(label = sprintf("%.2f", metric_value)), # Format to 2 decimal places
      vjust = -1.5, # Position text just above the point
      size = 3.5,
      show.legend = FALSE # Prevent text from getting a legend entry
    ) +
    
    # Apply your custom color scheme to the lines and points
    scale_color_manual(name = "Class", values = metric_plot_colors) +
    # Manually define shapes for better accessibility (e.g., color-blind friendly)
    scale_shape_manual(name = "Class", values = c("water" = 16, "dry" = 17)) + # 16=filled circle, 17=filled triangle
    
    # Set y-axis limits to be 0-1
    coord_cartesian(ylim = c(0, 1.05)) + # Go slightly above 1 to make room for text
    
    # Customize labels and theme
    labs(
      title = "Model Performance Trend Across Mixture Levels",
      subtitle = paste("Site:", study_site_name, "| Year:", study_year),
      x = "Mixture Level",
      y = "Score"
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      plot.subtitle = element_text(hjust = 0.5, size = 12),
      strip.text = element_text(face = "bold", size = 11), # Facet titles (recall, precision, etc.)
      legend.position = "top"
    )
  
  # 5. Save the plot to a file
  # This uses variables like 'output_root_dir' defined in your script's configuration section.
  plot_output_dir <- file.path(output_root_dir, "plots", study_site_name, study_year)
  if (!dir.exists(plot_output_dir)) {
    message(paste("    Creating plot output directory:", plot_output_dir))
    dir.create(plot_output_dir, recursive = TRUE)
  }
  
  plot_output_dir <- file.path(output_root_dir, "plots", study_site_name, study_year)
  plot_filename <- paste0(study_site_name, "_", study_year, "_metrics_line_plot.png")
  plot_filepath <- file.path(plot_output_dir, plot_filename)
  
  message(paste("    Saving plot to:", plot_filepath))
  tryCatch({
    ggsave(
      filename = plot_filepath,
      plot = metrics_line_plot,
      width = 10, # inches
      height = 6, # inches
      dpi = 300
    )
    message("    Plot saved successfully.")
  }, error = function(e) {
    message(paste("[WARN] Could not save the line plot. Reason:", e$message))
  })
  
  print(metrics_line_plot)
  message("--> Metrics line plot generated successfully. ✅")
}

# --- 4.5: Visualize Reference vs. Prediction Mapping ---

message("\n--> Generating overall plot to visualize mapping of reference labels to predictions...")

# Prerequisites: Check for necessary data and packages.
if (!exists("pixel_data_df") || !all(c("dominant_label", "predicted_jussila") %in% names(pixel_data_df))) {
  message("    [WARN] 'pixel_data_df' with 'dominant_label' and 'predicted_jussila' not found. Skipping plot.")
} else if (!requireNamespace("scales", quietly = TRUE)) {
  message("    [WARN] 'scales' package not found (needed for formatting percentages). Skipping plot.")
} else {
  
  # 1. Prepare data by counting each combination of reference vs. prediction.
  message("    Summarizing prediction counts for each reference label...")
  plot_data_flow <- pixel_data_df %>%
    filter(!is.na(dominant_label) & !is.na(predicted_jussila)) %>%
    count(dominant_label, predicted_jussila, name = "pixel_count") %>%
    group_by(dominant_label) %>%
    mutate(proportion = pixel_count / sum(pixel_count)) %>%
    ungroup()
  
  if (nrow(plot_data_flow) == 0) {
    message("    [INFO] No data available to plot after filtering and counting.")
  } else {
    
    # 2. Define colors for the prediction classes ("water" and "dry").
    prediction_colors <- c(
      "water" = "#4cd2de",
      "dry" = "#dc5199"
    )
    
    # --- SET CUSTOM AXIS ORDER ---
    message("    Applying manual order to the y-axis labels for consistency...")
    # Define your desired order from top to bottom.
    manual_order <- c('inundated', 'not inundated', 'other', 'uncertain')
    
    # ggplot plots factors from the first level at the bottom to the last level at the top.
    # To get our desired order, we reverse it for the 'levels' argument.
    # We also filter for levels that are actually in the data to avoid errors.
    levels_present_in_data <- manual_order[manual_order %in% unique(plot_data_flow$dominant_label)]
    plot_data_flow$dominant_label <- factor(plot_data_flow$dominant_label, levels = rev(levels_present_in_data))
    # --- END OF ORDERING ---
    
    # 3. Prepare titles with automatic line wrapping.
    main_title_text <- "How Reference Labels Map to Model Predictions (Overall)"
    subtitle_text <- "Each bar shows the proportional breakdown of model predictions for a given reference label"
    wrapped_title <- paste(strwrap(main_title_text, width = 50), collapse = "\n")
    wrapped_subtitle <- paste(strwrap(subtitle_text, width = 60), collapse = "\n")
    
    # 4. Create the 100% stacked bar chart.
    message("    Generating 100% stacked bar chart...")
    mapping_plot <- ggplot(plot_data_flow, 
                           aes(y = dominant_label, x = proportion, fill = predicted_jussila)) +
      
      geom_col(position = "fill") +
      geom_text(
        aes(label = scales::percent(proportion, accuracy = 1)),
        position = position_fill(vjust = 0.5),
        color = "white",
        fontface = "bold",
        size = 3.5
      ) +
      scale_fill_manual(
        name = "Model Prediction",
        values = prediction_colors
      ) +
      scale_y_discrete(drop = FALSE) + # Ensures all factor levels are shown, even if they have no data
      scale_x_continuous(labels = scales::percent) +
      labs(
        title = wrapped_title,
        subtitle = wrapped_subtitle,
        x = "Proportion of Predictions",
        y = "Reference Label"
      ) +
      theme_bw() + 
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 10),
        legend.position = "top"
      )
    
    print(mapping_plot)
    message("--> Overall mapping visualization generated successfully. ✅")
    
    # 5. Save the plot.
    plot_output_dir <- file.path(output_root_dir, "plots", study_site_name, study_year)
    if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
    plot_filename <- paste0(study_site_name, "_", study_year, "_label_mapping_plot_overall.png")
    plot_filepath <- file.path(plot_output_dir, plot_filename)
    
    message(paste("    Saving plot to:", plot_filepath))
    tryCatch({
      ggsave(
        filename = plot_filepath,
        plot = mapping_plot,
        width = 8, 
        height = 6,
        dpi = 300
      )
      message("    Plot saved successfully.")
    }, error = function(e) {
      message(paste("[WARN] Could not save the plot. Reason:", e$message))
    })
  }
}

# --- Generate and Save Faceted Mapping Plot by Mixture Level ---
message("\n--> Generating faceted plot to visualize reference vs. prediction mapping by mixture level...")

# Prerequisites: Check for necessary data and packages.
if (!exists("pixel_data_df") || !all(c("dominant_label", "predicted_jussila", "mixture_category") %in% names(pixel_data_df))) {
  message("    [WARN] 'pixel_data_df' with required columns not found. Skipping plot.")
} else if (!requireNamespace("scales", quietly = TRUE)) {
  message("    [WARN] 'scales' package not found (needed for formatting percentages). Skipping plot.")
} else {
  
  # 1. Prepare data by counting each combination, including mixture_category.
  message("    Summarizing prediction counts for each reference label within each mixture level...")
  plot_data_faceted <- pixel_data_df %>%
    filter(!is.na(dominant_label) & !is.na(predicted_jussila) & !is.na(mixture_category)) %>%
    count(mixture_category, dominant_label, predicted_jussila, name = "pixel_count") %>%
    group_by(mixture_category, dominant_label) %>%
    mutate(proportion = pixel_count / sum(pixel_count)) %>%
    ungroup()
  
  if (nrow(plot_data_faceted) == 0) {
    message("    [INFO] No data available to plot after filtering and counting.")
  } else {
    
    # 2. Define colors for the prediction classes ("water" and "dry").
    prediction_colors <- c(
      "water" = "#4cd2de",
      "dry" = "#dc5199"
    )
    
    # 3. Order factors for a clean plot layout.
    plot_data_faceted$mixture_category <- factor(plot_data_faceted$mixture_category, levels = c("pure", "mixed", "very_mixed"))
    manual_order <- c('inundated', 'not inundated', 'other', 'uncertain')
    # Use rev() to have 'inundated' appear at the top in a horizontal plot
    plot_data_faceted$dominant_label <- factor(plot_data_faceted$dominant_label, levels = rev(manual_order))
    
    # 4. Prepare titles with automatic line wrapping.
    main_title_text <- "How Reference Labels Map to Model Predictions, by Mixture Level"
    subtitle_text <- "Each panel shows a different mixture category of reference pixels"
    wrapped_title <- paste(strwrap(main_title_text, width = 60), collapse = "\n")
    wrapped_subtitle <- paste(strwrap(subtitle_text, width = 70), collapse = "\n")
    
    # 5. Create the 100% stacked bar chart, faceted by mixture_category.
    message("    Generating faceted 100% stacked bar chart...")
    faceted_mapping_plot <- ggplot(plot_data_faceted, 
                                   aes(x = dominant_label, y = proportion, fill = predicted_jussila)) +
      geom_col(position = "fill") +
      facet_wrap(~ mixture_category, ncol = 3) + # Creates 3 panels, side-by-side
      geom_text(
        aes(label = if_else(proportion > 0.02, scales::percent(proportion, accuracy = 1), "")),
        position = position_fill(vjust = 0.5),
        color = "white",
        fontface = "bold",
        size = 3.5
      ) +
      scale_fill_manual(name = "Model Prediction", values = prediction_colors) +
      scale_y_continuous(labels = scales::percent) +
      coord_flip() +
      labs(
        title = wrapped_title,
        subtitle = wrapped_subtitle,
        x = "Reference Label",
        y = "Proportion of Predictions"
      ) +
      theme_bw() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 10),
        strip.text = element_text(face = "bold", size = 11),
        legend.position = "top"
      )
    
    print(faceted_mapping_plot)
    message("--> Faceted mapping visualization generated successfully. ✅")
    
    # 6. Save the plot to a file.
    plot_output_dir <- file.path(output_root_dir, "plots", study_site_name, study_year)
    if (!dir.exists(plot_output_dir)) dir.create(plot_output_dir, recursive = TRUE)
    plot_filename <- paste0(study_site_name, "_", study_year, "_label_mapping_faceted_plot.png")
    plot_filepath <- file.path(plot_output_dir, plot_filename)
    
    message(paste("    Saving plot to:", plot_filepath))
    tryCatch({
      # A wider dimension is used to accommodate the three side-by-side facets.
      ggsave(
        filename = plot_filepath,
        plot = faceted_mapping_plot,
        width = 12, # inches
        height = 7, # inches
        dpi = 300
      )
      message("    Plot saved successfully.")
    }, error = function(e) {
      message(paste("[WARN] Could not save the plot. Reason:", e$message))
    })
  }
}

message("\n--- Script processing finished. ---")
